// Generated by CoffeeScript 1.4.0

(function() {
  "use strict";
  var Backbone, exports, isManyType, isOneType, _;
  if (typeof window === 'undefined') {
    _ = require('underscore');
    Backbone = require('backbone');
    exports = module.exports = Backbone;
  } else {
    _ = window._;
    Backbone = window.Backbone;
    exports = window;
  }
  Backbone.JJRelational = {};
  Backbone.JJRelational.CollectionTypes = {};
  /*
  	 # 
  	 # GENERAL FUNCTIONS
  	 #
  */

  /*
  	 # Find a type on the global object by name. Splits name on dots (i.e. 'Store.Models.MyModel' will return exports['Store']['Models']['MyModel'])
  	 # @param {String} name
  	 #
  */

  Backbone.JJRelational.getObjectByName = function(name) {
    var type;
    type = _.reduce(name.split('.'), function(memo, val) {
      return memo[val];
    }, exports);
    if (type !== exports) {
      return type;
    } else {
      return null;
    }
  };
  /*
  	 # registers a collection-type, in order to create a correct collection instance for many-relations
  	 # @param {[Object]} collTypes
  	 #
  */

  Backbone.JJRelational.registerCollectionTypes = function(collTypes) {
    var collection, name;
    if (!_.isObject(collTypes)) {
      return;
    }
    for (name in collTypes) {
      collection = collTypes[name];
      Backbone.JJRelational.CollectionTypes[name] = collection;
    }
    return true;
  };
  /*
  	 # gets a collection-type by the registered name
  	 # if none is found, Backbone.Collection will be returned
  	 # @param {String} name
  	 #
  */

  Backbone.JJRelational.getCollectionType = function(name) {
    var coll, n, _ref;
    _ref = Backbone.JJRelational.CollectionTypes;
    for (n in _ref) {
      coll = _ref[n];
      if (n === name) {
        return coll;
      }
    }
    return Backbone.Collection;
  };
  /*
  	 #
  	 # the relational model extension of Backbone.Model
  	 #
  */

  Backbone.JJRelationalModel = Backbone.Model.extend({
    /*
    	 	 # 
    	 	 # Overwrite Backbone.Model.constructor
    	 	 #
    */

    constructor: function(attributes, options) {
      Backbone.Model.apply(this, arguments);
      this.prepopulate_rel_atts();
      this.populate_rels_with_atts(attributes);
      return this;
    },
    /*
    		 #
    		 # initializes the relational attributes. has_many and many_many get empty collections, has_one gets null,
    		 #
    		 #
    */

    prepopulate_rel_atts: function() {
      var collType, globalScopeObj, relModel, relation, value, _i, _len, _ref;
      if (this.relations) {
        _ref = this.relations;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          relation = _ref[_i];
          relModel = relation.relatedModel;
          if (relModel === void 0 || relModel.prototype instanceof Backbone.JJRelationalModel === false) {
            if (_.isString(relModel)) {
              globalScopeObj = Backbone.JJRelational.getObjectByName(relModel);
              if (globalScopeObj && globalScopeObj.prototype instanceof Backbone.JJRelationalModel === true) {
                relation.relatedModel = globalScopeObj;
              } else {
                throw new TypeError('relatedModel "' + relModel + '" is neither a reference to a JJRelationalModel nor a string referring to an object in the global scope');
              }
            }
          }
          value;
          if (relation && relation.type !== 'has_one' && (collType = Backbone.JJRelational.getCollectionType(relation.collectionType))) {
            value = new collType();
            value._relational = {
              owner: this,
              ownerKey: relation.key,
              reverseKey: relation.reverseKey
            };
            value.bind('relational:remove', value._relatedModelRemoved);
            value.bind('relational:reset', value._cleanup);
          } else {
            value = null;
          }
          this.attributes[relation.key] = value;
          this.bind('change:' + relation.key, this.relFieldChanged);
        }
        this.bind('destroy', this._cleanupAllRelations);
      }
      return this;
    },
    /*
    		 #
    		 # fills in any relational values that have been passed in the constructor
    		 # i.e. var m = new MyModel({ HasOneRelation : relationalModel });
    		 # @param {Object} constructor_atts (@source Backbone.JJRelationalModel.constructor)
    		 #
    */

    populate_rels_with_atts: function(attributes) {
      var checkAndAdd, key, relation, v, value, _i, _len,
        _this = this;
      checkAndAdd = function(val, rel) {
        var newModel;
        if (val instanceof relation.relatedModel === true) {
          return _this.addToRelation(val, rel, false);
        } else if (_.isObject(val) && val instanceof Backbone.Model === false) {
          newModel = new rel.relatedModel(val);
          return _this.addToRelation(newModel, rel, false);
        }
      };
      for (key in attributes) {
        value = attributes[key];
        if (relation = this.getRelationByKey(key)) {
          if (value instanceof Backbone.Collection === true) {
            throw new TypeError('The attribute "' + key + '" is a collection. You should not replace whole collections in a relational attribute. Please use the direct reference to the model array (Backbone.Collection.models)');
          } else {
            value = _.isArray(value) ? value : [value];
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              v = value[_i];
              checkAndAdd(v, relation);
            }
          }
        }
      }
      return this;
    },
    /*
    		 #
    		 # general function when a relation field has changed
    		 #
    */

    relFieldChanged: function(model, attribute, options) {
      var attrName, found, relation, status, _ref;
      if (options.silentRelation === true) {
        return;
      }
      found = false;
      _ref = options.changes;
      for (attrName in _ref) {
        status = _ref[attrName];
        if (found === false && status === true) {
          if (this.get(attrName) === attribute) {
            found = true;
            relation = this.getRelationByKey(attrName);
            if (relation) {
              this.trigger('relational:change:' + relation.key);
              if (relation.type === 'has_one') {
                this.unbind('relational:change:' + relation.key);
                if (attribute instanceof relation.relatedModel === true) {
                  this.setHasOneListeners(relation.key, relation.reverseKey, attribute);
                  attribute.addToRelation(this, relation.reverseKey, true);
                } else if (attribute) {
                  throw new TypeError('Attribute "' + relation.key + '" is no instance of specified related model.');
                }
              } else if (isManyType(relation)) {
                throw new Warning('You have used \'set\' on the attribute of a many-relation. That\'s bad, man. Please use get("' + relation.key + '") and perform collection operations');
              }
            }
          }
        }
      }
      return false;
    },
    /*
    		 # functions for adding a model to a relation
    		 # @param {Backbone.JJRelationalModel} model
    		 # @param {String} relationKey
    		 # @param {Boolean} silent
    */

    addToRelation: function(model, relation, silent) {
      if (!_.isObject(relation)) {
        relation = this.getRelationByKey(relation);
      }
      if (relation && (model instanceof relation.relatedModel === true)) {
        if (isOneType(relation)) {
          this.set(relation.key, model, {
            silentRelation: silent
          });
          this.setHasOneListeners(relation.key, relation.reverseKey, model);
        } else if (isManyType(relation)) {
          this.get(relation.key).add(model, {
            silentRelation: silent
          });
        }
      }
      return false;
    },
    removeFromRelation: function(relation, model, silent) {
      if (!_.isObject(relation)) {
        relation = this.getRelationByKey(relation);
      }
      if (relation) {
        if (isOneType(relation)) {
          this.unbind('relational:change:' + relation.key);
          this.set(relation.key, null, {
            silentRelation: silent
          });
        } else if (isManyType(relation)) {
          this.get(relation.key).remove(model, {
            silentRelation: silent
          });
        }
      }
      return this;
    },
    setHasOneListeners: function(key, reverseKey, model) {
      this.bind('relational:change:' + key, function() {
        return model.removeFromRelation(reverseKey, this, true);
      });
      return this;
    },
    /*
    		 # cleanup function that removes all listeners and informs relations of removal
    */

    _cleanupAllRelations: function() {
      var relModel, relation, _i, _len, _ref;
      _ref = this.relations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        relation = _ref[_i];
        this.unbind('relational:change:' + relation.key);
        this.unbind('change:' + relation.key, this.relFieldChanged);
        this.unbind('destroy', this._cleanupAllRelations);
        if (isOneType(relation) && (relModel = this.get(relation.key))) {
          this.set(relation.key, null, false);
        }
        if (isManyType(relation)) {
          this.get(relation.key)._cleanup(false, true);
        }
      }
      return this;
    },
    /*
    		 # @begin helper functions
    */

    getRelationByKey: function(key) {
      var relation, _i, _len, _ref;
      _ref = this.relations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        relation = _ref[_i];
        if (relation.key === key) {
          return relation;
        }
      }
      return false;
    },
    getRelationByReverseKey: function(key) {
      var relation, _i, _len, _ref;
      _ref = this.relations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        relation = _ref[_i];
        if (relation.reverseKey === key) {
          return relation;
        }
      }
      return false;
    }
    /*
    		 # @end helper functions
    */

  });
  /*
  	 #
  	 # Collection hacks
  	 #
  */

  Backbone.Collection.prototype._add = Backbone.Collection.prototype.add;
  Backbone.Collection.prototype.add = function(models, options) {
    var model, modelToAdd, modelsToAdd, _i, _j, _len, _len1;
    if (!this._relational) {
      return this._add(models, options);
    }
    if (this._relational) {
      options || (options = {});
      if (!_.isArray(models)) {
        models = [models];
      }
      modelsToAdd = [];
      for (_i = 0, _len = models.length; _i < _len; _i++) {
        model = models[_i];
        if (model instanceof Backbone.Model === false) {
          model = this._prepareModel(model);
        }
        if (model instanceof this.model === false) {
          throw new TypeError('Invalid model to be added to collection with relation key "' + this._relational.ownerKey + '"');
        } else {
          modelsToAdd.push(model);
        }
      }
      if (!options.silentRelation) {
        for (_j = 0, _len1 = modelsToAdd.length; _j < _len1; _j++) {
          modelToAdd = modelsToAdd[_j];
          this._setHasManyListeners(modelToAdd);
          modelToAdd.addToRelation(this._relational.owner, this._relational.reverseKey, true);
        }
      }
    }
    return this._add(modelsToAdd, options);
  };
  Backbone.Collection.prototype.__remove = Backbone.Collection.prototype.remove;
  Backbone.Collection.prototype.remove = function(models, options) {
    var _this = this;
    options || (options = {});
    if (!_.isArray(models)) {
      models = [models];
    } else {
      models = models.slice(0);
    }
    _.each(models, function(model) {
      if (model instanceof Backbone.Model === true) {
        _this.__remove(model, options);
        if (!options.silentRelation) {
          return _this.trigger('relational:remove', model, options);
        }
      }
    });
    return this;
  };
  Backbone.Collection.prototype._cleanup = function(call_remove, unbind) {
    if (call_remove) {
      this.remove(this.models, {
        silentRelation: false
      });
    }
    if (unbind) {
      this.unbind('relational:remove');
      this.unbind('relational:reset');
    }
    return this;
  };
  Backbone.Collection.prototype._relatedModelRemoved = function(model, options) {
    var silent;
    if (options.silentRelation) {
      silent = false;
    } else {
      silent = true;
    }
    model.removeFromRelation(this._relational.reverseKey, this._relational.owner, silent);
    return this;
  };
  Backbone.Collection.prototype._setHasManyListeners = function(model) {
    return this;
  };
  Backbone.Collection.prototype.__reset = Backbone.Collection.prototype.reset;
  Backbone.Collection.prototype.reset = function(models, options) {
    this.trigger('relational:reset', true, false);
    this.__reset(models, options);
    return this;
  };
  isOneType = function(relation) {
    if (relation.type === 'has_one') {
      return true;
    } else {
      return false;
    }
  };
  isManyType = function(relation) {
    if (relation.type === 'has_many' || relation.type === 'many_many') {
      return true;
    } else {
      return false;
    }
  };
  return this;
})();
